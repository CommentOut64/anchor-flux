# 开发文档：预加载重构与流水线切换

> 文档版本：v1.0
> 创建日期：2025年12月7日
> 状态：待实施

---

## 一、问题概述

### 1.1 当前问题

1. **BGM 检测仍使用三点采样**
   - 队列服务 `job_queue_service.py` 始终调用 `_run_pipeline()`（Whisper 流水线）
   - Whisper 流水线使用 `_detect_bgm()` 进行三点采样 BGM 检测
   - 新的 SenseVoice 流水线 `_process_video_sensevoice()` 使用频谱分诊，但**从未被调用**

2. **Whisper 预加载不必要**
   - `model_preload_manager.py` 预加载 Whisper 模型
   - SenseVoice 流水线不需要 Whisper（除了后处理补刀阶段）
   - 启动时加载 Whisper 模型浪费资源和时间

3. **缺少 Demucs 预加载**
   - Demucs 模型首次使用时才加载，导致首次分离延迟
   - 应该在启动时预加载默认的人声分离模型

---

## 二、修改方案

### 2.1 流水线选择（已完成 ✅）

**文件**：`backend/app/services/job_queue_service.py`

**修改位置**：第 319 行附近

**修改内容**：根据 `job.settings.engine` 选择流水线

```python
# 修改前
self.transcription_service._run_pipeline(job)

# 修改后
engine = getattr(job.settings, 'engine', 'whisper')
if engine == 'sensevoice':
    # SenseVoice 流水线（异步，使用频谱分诊）
    logger.info(f"使用 SenseVoice 流水线")
    import asyncio
    asyncio.run(self.transcription_service._process_video_sensevoice(job))
else:
    # Whisper 流水线（同步，使用三点采样）
    logger.info(f"使用 Whisper 流水线")
    self.transcription_service._run_pipeline(job)
```

**状态**：已完成

---

### 2.2 禁用 Whisper 预加载

**文件**：`backend/app/services/model_preload_manager.py`

#### 方案 A：完全禁用 Whisper 预加载

**修改位置**：`preload_models()` 方法（约第 142 行）

**修改思路**：
1. 删除或注释掉 Whisper 模型加载部分（第 232-340 行）
2. 保留 Silero VAD 预加载（第 206-230 行）
3. 新增 Demucs 预加载逻辑

**修改示例**：

```python
async def preload_models(self, progress_callback=None) -> Dict[str, Any]:
    """预加载默认模型 - 重构版：Demucs + VAD，无 Whisper
    
    预加载逻辑：
    1. 预加载 Silero VAD 模型（内置，快速）
    2. 预加载默认 Demucs 模型（htdemucs）
    3. 【移除】不再预加载 Whisper 模型
    """
    with self._global_lock:
        if self._preload_status["is_preloading"]:
            self.logger.info("预加载已在进行中，返回已有任务")
            return {"success": True, "message": "预加载已在进行中"}

        if not self.config.enabled:
            self.logger.warning("模型预加载功能已禁用")
            return {"success": False, "message": "预加载功能已禁用"}

        self._preload_status.update({
            "is_preloading": True,
            "progress": 0.0,
            "current_model": "",
            "total_models": 2,  # VAD + Demucs
            "loaded_models": 0,
            "errors": [],
            "last_attempt_time": time.time()
        })

    try:
        success_count = 0

        # ===== 1. 预加载 Silero VAD 模型（保留原逻辑）=====
        try:
            self.logger.info("[预加载] 加载 Silero VAD 模型...")
            with self._global_lock:
                self._preload_status.update({
                    "current_model": "Silero VAD",
                    "progress": 0.0
                })

            from pathlib import Path as PathlibPath
            from silero_vad.utils_vad import OnnxWrapper

            builtin_model_path = PathlibPath(__file__).parent.parent / "assets" / "silero" / "silero_vad.onnx"

            if builtin_model_path.exists():
                _ = OnnxWrapper(str(builtin_model_path), force_onnx_cpu=False)
                self.logger.info("Silero VAD 模型预加载成功")
                success_count += 1
                with self._global_lock:
                    self._preload_status["loaded_models"] += 1
            else:
                self.logger.warning(f"Silero VAD 模型缺失: {builtin_model_path}")

        except Exception as e:
            self.logger.warning(f"Silero VAD 预加载失败（非致命）: {e}")

        # ===== 2. 预加载 Demucs 模型（新增）=====
        try:
            self.logger.info("[预加载] 加载 Demucs 模型...")
            with self._global_lock:
                self._preload_status.update({
                    "current_model": "Demucs (htdemucs)",
                    "progress": 50.0
                })

            from services.demucs_service import get_demucs_service
            demucs_service = get_demucs_service()
            
            # 预加载默认模型 htdemucs
            demucs_service.set_model("htdemucs")
            demucs_service.preload_model()  # 需要在 DemucsService 中添加此方法
            
            self.logger.info("Demucs 模型预加载成功")
            success_count += 1
            with self._global_lock:
                self._preload_status["loaded_models"] += 1

        except Exception as e:
            self.logger.warning(f"Demucs 预加载失败（非致命）: {e}")
            with self._global_lock:
                self._preload_status["errors"].append(f"Demucs 预加载失败: {e}")

        # ===== 【移除】不再预加载 Whisper 模型 =====
        # 原来的 Whisper 预加载代码已删除
        # Whisper 仅在后处理补刀阶段按需加载

        # 完成预加载
        success = success_count > 0
        
        with self._global_lock:
            self._preload_status.update({
                "is_preloading": False,
                "progress": 100.0,
                "current_model": "",
                "cache_version": int(time.time())
            })
        
        return {
            "success": success,
            "loaded_models": success_count,
            "total_models": 2,
            "errors": self._preload_status["errors"].copy()
        }

    except Exception as e:
        self.logger.error(f"预加载异常: {e}", exc_info=True)
        with self._global_lock:
            self._preload_status.update({
                "is_preloading": False,
                "progress": 0.0,
                "errors": [str(e)]
            })
        return {"success": False, "message": str(e)}
```

---

### 2.3 DemucsService 添加预加载方法

**文件**：`backend/app/services/demucs_service.py`

**修改位置**：`DemucsService` 类中，约第 310 行 `set_model()` 方法后

**新增方法**：

```python
def preload_model(self, model_name: str = None) -> bool:
    """
    预加载 Demucs 模型到显存
    
    Args:
        model_name: 模型名称，默认使用当前配置的模型
        
    Returns:
        bool: 是否加载成功
    """
    if model_name:
        self.set_model(model_name)
    
    try:
        self.logger.info(f"预加载 Demucs 模型: {self.config.model_name}")
        self._load_model()
        self.logger.info(f"Demucs 模型 {self.config.model_name} 预加载完成")
        return True
    except Exception as e:
        self.logger.error(f"Demucs 模型预加载失败: {e}")
        return False

def is_model_loaded(self) -> bool:
    """检查模型是否已加载"""
    return self._model is not None

def get_loaded_model_name(self) -> Optional[str]:
    """获取当前加载的模型名称"""
    return self._model_name_loaded
```

---

### 2.4 BGM 检测为 NONE 时卸载 Demucs 模型

**文件**：`backend/app/services/transcription_service.py`

#### 对于 Whisper 流水线（`_run_pipeline`）

**修改位置**：约第 1448 行，`_detect_bgm()` 调用后

**修改内容**：

```python
# 执行BGM检测（如果启用且模式需要）
if demucs_settings.enabled and demucs_settings.mode in ["auto", "always"]:
    bgm_level, bgm_ratios = self._detect_bgm(str(audio_path), job)
    self.logger.info(f"BGM检测完成: {bgm_level.value}")
    
    # 【新增】如果 BGM 检测结果为 NONE，立即卸载 Demucs 模型释放显存
    if bgm_level == BGMLevel.NONE:
        from services.demucs_service import get_demucs_service
        demucs_service = get_demucs_service()
        if demucs_service.is_model_loaded():
            self.logger.info("BGM 检测为 NONE，卸载 Demucs 模型释放显存")
            demucs_service.unload_model()
```

#### 对于 SenseVoice 流水线（`_process_video_sensevoice`）

**修改位置**：约第 4340 行，频谱分诊完成后

**修改内容**：

```python
# 3. 频谱分诊（Chunk级别）
progress_tracker.start_phase(ProcessPhase.BGM_DETECT, 1, "频谱分诊...")
spectrum_classifier = get_spectrum_classifier()
diagnoses = spectrum_classifier.diagnose_chunks(
    [(audio_array[int(s['start']*sr):int(s['end']*sr)], s['start'], s['end'])
     for s in vad_segments],
    sr=sr
)
progress_tracker.complete_phase(ProcessPhase.BGM_DETECT)

# 【新增】检查是否所有 Chunk 都不需要分离
chunks_need_separation = sum(1 for d in diagnoses if d.need_separation)
if chunks_need_separation == 0:
    # 没有 Chunk 需要分离，卸载 Demucs 模型释放显存
    self.logger.info("所有 Chunk 均为纯净人声，卸载 Demucs 模型")
    demucs_service = get_demucs_service()
    if demucs_service.is_model_loaded():
        demucs_service.unload_model()
```

---

### 2.5 DemucsService 卸载方法（已存在 ✅）

**文件**：`backend/app/services/demucs_service.py`

**位置**：第 378 行

`unload_model()` 方法已存在，无需添加。

只需添加 `is_model_loaded()` 辅助方法：

```python
def is_model_loaded(self) -> bool:
    """检查模型是否已加载"""
    return self._model is not None
```

---

## 三、文件修改清单

| 文件 | 修改类型 | 修改内容 | 状态 |
|------|----------|----------|------|
| `job_queue_service.py` | 修改 | 根据 engine 选择流水线 | ✅ 已完成 |
| `model_preload_manager.py` | 重构 | 禁用 Whisper 预加载，新增 Demucs 预加载 | ✅ 已完成 |
| `demucs_service.py` | 新增方法 | `preload_model()`, `is_model_loaded()`, `get_loaded_model_name()` | ✅ 已完成 |
| `transcription_service.py` | 修改 | BGM=NONE 时卸载 Demucs（Whisper/SenseVoice 双流水线） | ✅ 已完成 |

---

## 四、测试要点

### 4.1 流水线选择测试

```bash
# 测试 SenseVoice 流水线
curl -X POST http://localhost:8000/api/transcription/start \
  -H "Content-Type: application/json" \
  -d '{"file": "test.mp4", "engine": "sensevoice"}'

# 观察日志应出现：
# - "使用 SenseVoice 流水线"
# - "频谱分诊完成: X chunks, Y 需要分离"
# 不应出现：
# - "BGM检测完成: 比例=[...]"（三点采样日志）
```

### 4.2 预加载测试

```bash
# 启动服务后观察日志
# 应该看到：
# - "[预加载] 加载 Silero VAD 模型..."
# - "[预加载] 加载 Demucs 模型..."
# 不应看到：
# - "开始加载新Whisper模型"
# - "加载 Faster-Whisper 模型"
```

### 4.3 Demucs 卸载测试

```bash
# 使用纯净人声音频测试
# 观察日志应出现：
# - "所有 Chunk 均为纯净人声，卸载 Demucs 模型"
# 或
# - "BGM 检测为 NONE，卸载 Demucs 模型释放显存"

# 检查显存：
nvidia-smi  # Demucs 卸载后显存应明显下降
```

---

## 五、回滚方案

如果修改导致问题，可以通过以下方式回滚：

### 5.1 回滚流水线选择

```python
# job_queue_service.py 第 319 行
# 改回原来的代码：
self.transcription_service._run_pipeline(job)
```

### 5.2 回滚预加载

保留 `model_preload_manager.py` 的原始版本，或者恢复 Whisper 预加载代码块。

---

## 六、后续优化建议

1. **配置化预加载策略**
   - 在 `user_config.json` 中添加预加载配置项
   - 允许用户选择预加载 Whisper / Demucs / 两者都加载 / 都不加载

2. **智能预加载**
   - 根据历史任务统计，自动决定预加载策略
   - 如果最近任务大多需要分离，预加载 Demucs
   - 如果最近任务大多使用 Whisper 补刀，预加载 Whisper

3. **懒加载 Whisper**
   - Whisper 补刀功能改为懒加载
   - 仅在 `_whisper_patch_sentence()` 首次调用时加载

---

## 七、相关文件路径

```
backend/app/services/
├── job_queue_service.py          # 队列服务（流水线选择）
├── model_preload_manager.py      # 预加载管理器
├── demucs_service.py             # Demucs 服务
├── transcription_service.py      # 转录服务（两个流水线）
├── audio_spectrum_classifier.py  # 频谱分诊器（SenseVoice 流水线使用）
└── whisper_service.py            # Whisper 服务（后处理补刀）
```

---

## 八、关键代码位置索引

| 功能 | 文件 | 行号范围 |
|------|------|----------|
| 队列执行任务 | `job_queue_service.py` | 313-340 |
| Whisper 流水线入口 | `transcription_service.py` | 1343 (`_run_pipeline`) |
| Whisper 流水线 BGM 检测 | `transcription_service.py` | 1429-1450 |
| SenseVoice 流水线入口 | `transcription_service.py` | 4287 (`_process_video_sensevoice`) |
| SenseVoice 频谱分诊 | `transcription_service.py` | 4333-4342 |
| 预加载主方法 | `model_preload_manager.py` | 142-380 (`preload_models`) |
| Whisper 模型加载 | `model_preload_manager.py` | 232-340 |
| Demucs set_model | `demucs_service.py` | 310 |
| Demucs _load_model | `demucs_service.py` | 327 |
| 频谱分诊器 | `audio_spectrum_classifier.py` | 19 (`AudioSpectrumClassifier`) |
