## 9. 前端进度系统调整

### 9.1 当前前端进度系统分析

**优点**:
- 完整的状态管理（Pinia Store）
- 支持撤销重做
- 本地持久化

**问题**:
- 大量字幕更新时缺乏节流机制
- 缺乏 SSE 连接状态可视化
- 草稿和定稿的样式切换不够明显

### 9.2 前端字幕状态模型

**文件**: `frontend/src/models/subtitle.js`

```javascript
export class SubtitleItem {
  constructor(data) {
    this.id = data.id || data.temp_id
    this.text = data.text
    this.start = data.start
    this.end = data.end
    this.words = data.words || []
    this.confidence = data.confidence || 1.0
    this.isDraft = data.is_draft || false
    this.isPseudo = data.is_pseudo || false
    this.createdAt = Date.now()
    this.updatedAt = Date.now()
  }

  // 判断是否需要高亮警告
  needsWarning() {
    if (this.isDraft) return false
    return this.confidence < 0.6
  }

  // 获取样式类
  getStyleClass() {
    if (this.isDraft) {
      return 'subtitle-draft'  // 灰色斜体
    }
    if (this.needsWarning()) {
      return 'subtitle-warning'  // 黄色高亮
    }
    return 'subtitle-final'  // 黑色正体
  }

  // 更新为定稿
  updateToFinal(finalData) {
    this.text = finalData.text
    this.words = finalData.words || []
    this.confidence = finalData.confidence || 1.0
    this.isDraft = false
    this.updatedAt = Date.now()
  }
}
```

### 9.3 字幕更新节流

**文件**: `frontend/src/views/EditorView.vue`

```vue
<script setup>
import { ref, computed } from 'vue'
import { useProjectStore } from '@/stores/projectStore'
import { SubtitleItem } from '@/models/subtitle'
import { throttle } from 'lodash-es'

const projectStore = useProjectStore()
const pendingUpdates = ref([])

// 节流的字幕更新函数（每 100ms 批量更新一次）
const flushSubtitleUpdates = throttle(() => {
  if (pendingUpdates.value.length === 0) return

  // 批量更新
  for (const update of pendingUpdates.value) {
    const existingIndex = projectStore.subtitles.findIndex(
      s => s.id === update.id
    )

    if (existingIndex >= 0) {
      // 更新现有字幕
      projectStore.subtitles[existingIndex].updateToFinal(update)
    } else {
      // 添加新字幕
      projectStore.subtitles.push(new SubtitleItem(update))
    }
  }

  // 清空待更新队列
  pendingUpdates.value = []

  // 触发重新渲染
  projectStore.triggerUpdate()
}, 100)

// SSE 事件处理器
const handleStreamingSubtitle = (data) => {
  if (data.is_draft) {
    // 草稿立即上屏
    const subtitle = new SubtitleItem(data)
    projectStore.subtitles.push(subtitle)
  } else {
    // 定稿加入待更新队列
    pendingUpdates.value.push(data)
    flushSubtitleUpdates()
  }
}
</script>

<style scoped>
.subtitle-draft {
  color: #999;
  font-style: italic;
  opacity: 0.7;
}

.subtitle-final {
  color: #000;
  font-style: normal;
  opacity: 1;
}

.subtitle-warning {
  background-color: #fff3cd;
  border-left: 3px solid #ffc107;
}
</style>
```

### 9.4 SSE 连接状态指示器

**文件**: `frontend/src/components/SSEStatusIndicator.vue`

```vue
<template>
  <div :class="['sse-status', statusClass]">
    <span class="status-dot"></span>
    <span class="status-text">{{ statusText }}</span>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useUnifiedTaskStore } from '@/stores/unifiedTaskStore'

const taskStore = useUnifiedTaskStore()

const statusClass = computed(() => {
  switch (taskStore.sseConnectionStatus) {
    case 'connected':
      return 'status-connected'
    case 'connecting':
      return 'status-connecting'
    case 'disconnected':
      return 'status-disconnected'
    case 'error':
      return 'status-error'
    default:
      return 'status-unknown'
  }
})

const statusText = computed(() => {
  switch (taskStore.sseConnectionStatus) {
    case 'connected':
      return '实时连接'
    case 'connecting':
      return '连接中...'
    case 'disconnected':
      return '已断开'
    case 'error':
      return '连接错误'
    default:
      return '未知'
  }
})
</script>

<style scoped>
.sse-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 12px;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

.status-connected .status-dot {
  background-color: #52c41a;
  animation: pulse 2s infinite;
}

.status-connecting .status-dot {
  background-color: #faad14;
}

.status-disconnected .status-dot {
  background-color: #d9d9d9;
}

.status-error .status-dot {
  background-color: #ff4d4f;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}
</style>
```

### 9.5 双层进度条设计（V3.5新增）

#### 9.5.1 设计目标

V3.5双模态对齐架构需要区分草稿流（SenseVoice快流）和定稿流（Whisper慢流）的独立进度，提升用户对转录过程的感知。

**核心需求**：
- 实时显示草稿进度和定稿进度
- 进度条高度适中，确保视觉清晰度（不过细）
- 支持SSE事件驱动的实时更新

#### 9.5.2 视觉设计

```
┌─────────────────────────────────────────┐
│ 任务名称                        [阶段标签] │
├─────────────────────────────────────────┤
│ 草稿 ████████░░░░░░░░░░░░░░  45%        │  ← 灰色渐变，6px高
│                                          │  ← 4px间隔
│ 定稿 ██████░░░░░░░░░░░░░░░░  30%        │  ← 蓝绿渐变，6px高
└─────────────────────────────────────────┘
```

#### 9.5.3 数据模型扩展

**文件**: `frontend/src/stores/taskStore.js`

```javascript
// 任务状态扩展
task: {
  job_id: string,
  progress: number,        // 总体进度（兼容旧版）
  draftProgress: number,   // 草稿流进度（0-100）
  finalProgress: number,   // 定稿流进度（0-100）
  status: string,
  phase: string
}
```

#### 9.5.4 组件实现

**文件**: `frontend/src/components/editor/TaskMonitor/TaskCard.vue`

**模板代码**（替换第38-47行）：

```vue
<!-- 双层进度条 -->
<div v-if="showProgress" class="task-progress-dual">
  <!-- 草稿流进度 -->
  <div class="progress-row">
    <div class="progress-bar progress-bar--draft">
      <div
        class="progress-fill progress-fill--draft"
        :style="{ width: (task.draftProgress || 0) + '%' }"
      ></div>
    </div>
    <span class="progress-text progress-text--draft">
      草稿 {{ formatProgress(task.draftProgress || 0) }}%
    </span>
  </div>

  <!-- 定稿流进度 -->
  <div class="progress-row">
    <div class="progress-bar progress-bar--final">
      <div
        class="progress-fill progress-fill--final"
        :style="{ width: (task.finalProgress || 0) + '%' }"
      ></div>
    </div>
    <span class="progress-text progress-text--final">
      定稿 {{ formatProgress(task.finalProgress || 0) }}%
    </span>
  </div>
</div>
```

**样式代码**（替换第290-316行）：

```scss
// 双层进度条容器
.task-progress-dual {
  display: flex;
  flex-direction: column;
  gap: 4px;  // 两层之间的间隔
}

// 单行进度条（草稿或定稿）
.progress-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

// 进度条轨道
.progress-bar {
  flex: 1;
  height: 6px;  // 增加高度，从4px改为6px
  background: var(--border-muted);
  border-radius: 3px;
  overflow: hidden;

  // 草稿流轨道（灰色背景）
  &--draft {
    background: rgba(255, 255, 255, 0.05);
  }

  // 定稿流轨道（深色背景）
  &--final {
    background: rgba(2, 138, 197, 0.1);
  }
}

// 进度条填充
.progress-fill {
  height: 100%;
  transition: width 0.3s ease;

  // 草稿流填充（灰色渐变）
  &--draft {
    background: linear-gradient(90deg, #6b7280, #9ca3af);
  }

  // 定稿流填充（蓝绿渐变）
  &--final {
    background: linear-gradient(90deg, #028AC5, #3fb950);
  }
}

// 进度文本
.progress-text {
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  min-width: 60px;  // 增加宽度以容纳"草稿 45%"
  text-align: right;

  // 草稿流文本
  &--draft {
    color: #9ca3af;
  }

  // 定稿流文本
  &--final {
    color: #028AC5;
  }
}
```

#### 9.5.5 SSE事件处理扩展

**文件**: `frontend/src/services/sseChannelManager.js`

在 `subscribeJob` 方法的字幕事件部分（第220行后）添加：

```javascript
// === V3.5 双流事件（新增） ===
'subtitle.draft': (data) => {
  console.log(`[SSE Job ${jobId}] 草稿字幕:`, data)
  handlers.onSubtitleDraft?.(data)
},
'subtitle.overwrite': (data) => {
  console.log(`[SSE Job ${jobId}] 覆盖字幕:`, data)
  handlers.onSubtitleOverwrite?.(data)
},
```

#### 9.5.6 进度计算逻辑

**文件**: `frontend/src/views/EditorView.vue` 或 `frontend/src/stores/taskStore.js`

```javascript
// 监听SSE事件，更新任务进度
sseChannelManager.subscribeJob(jobId, {
  // 草稿流进度更新
  onSubtitleDraft: (data) => {
    // data.chunk_index: 当前处理的chunk索引
    // data.total_chunks: 总chunk数量
    const draftProgress = Math.round((data.chunk_index / data.total_chunks) * 100)
    updateTaskProgress(jobId, { draftProgress })
  },

  // 定稿流进度更新
  onSubtitleOverwrite: (data) => {
    const finalProgress = Math.round((data.chunk_index / data.total_chunks) * 100)
    updateTaskProgress(jobId, { finalProgress })
  },

  // 兼容旧版进度事件
  onProgress: (data) => {
    // 如果没有双流数据，使用总体进度
    if (!data.draftProgress && !data.finalProgress) {
      updateTaskProgress(jobId, {
        progress: data.percent,
        draftProgress: data.percent,
        finalProgress: data.percent
      })
    }
  }
})
```

#### 9.5.7 后端SSE事件格式

**subtitle.draft 事件**：
```json
{
  "temp_id": "chunk_5",
  "chunk_index": 5,
  "total_chunks": 20,
  "text": "这是草稿文本",
  "start": 10.5,
  "end": 15.3,
  "is_draft": true
}
```

**subtitle.overwrite 事件**：
```json
{
  "target_temp_id": "chunk_5",
  "chunk_index": 5,
  "total_chunks": 20,
  "text": "这是精修文本",
  "words": [...],
  "start": 10.5,
  "end": 15.3,
  "is_draft": false,
  "quality": {
    "alignment_rate": 0.85,
    "status": "success"
  }
}
```

#### 9.5.8 向后兼容处理

```vue
<!-- 自动降级逻辑 -->
<div v-if="showProgress" :class="hasDualProgress ? 'task-progress-dual' : 'task-progress'">
  <!-- 双层进度条 -->
  <template v-if="hasDualProgress">
    <!-- ... 双层进度条代码 ... -->
  </template>

  <!-- 单层进度条（兼容旧版） -->
  <template v-else>
    <div class="progress-bar">
      <div class="progress-fill" :style="{ width: task.progress + '%' }"></div>
    </div>
    <span class="progress-text">{{ formatProgress(task.progress) }}%</span>
  </template>
</div>
```

```javascript
const hasDualProgress = computed(() => {
  return props.task.draftProgress !== undefined || props.task.finalProgress !== undefined
})
```

#### 9.5.9 实施步骤

**Phase 1: 后端SSE事件（优先）**
1. 修改 `backend/app/services/streaming/sse_publisher.py`
2. 在 `DualAlignmentPipeline` 中调用新的发布方法
3. 测试SSE事件是否正确发送

**Phase 2: 前端事件处理**
1. 修改 `frontend/src/services/sseChannelManager.js`
2. 添加 `subtitle.draft` 和 `subtitle.overwrite` 事件处理器
3. 测试事件接收和日志输出

**Phase 3: 前端UI升级**
1. 修改 `frontend/src/components/editor/TaskMonitor/TaskCard.vue`
2. 实现双层进度条UI
3. 连接SSE事件到进度更新逻辑

**Phase 4: 状态管理**
1. 扩展任务状态模型（draftProgress, finalProgress）
2. 实现进度计算逻辑
3. 测试完整流程

---

## 10. GPU/CPU实时监测系统

### 10.1 硬件监测服务

**文件**: `backend/app/services/monitoring/hardware_monitor.py`

```python
import psutil
import torch
from typing import Dict, Optional
from dataclasses import dataclass
import asyncio

@dataclass
class GPUStatus:
    """GPU 状态"""
    index: int
    name: str
    memory_used: float  # MB
    memory_total: float  # MB
    memory_percent: float
    temperature: Optional[float] = None
    utilization: Optional[float] = None

@dataclass
class SystemStatus:
    """系统状态"""
    cpu_percent: float
    memory_used: float  # MB
    memory_total: float  # MB
    memory_percent: float
    gpus: List[GPUStatus]

class HardwareMonitor:
    """实时硬件监测器"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.monitoring = False
        self.monitor_task = None

    def get_gpu_memory_total(self) -> float:
        """获取 GPU 总显存（MB）"""
        if not torch.cuda.is_available():
            return 0.0
        return torch.cuda.get_device_properties(0).total_memory / 1024 / 1024

    def get_gpu_memory_available(self) -> float:
        """获取 GPU 可用显存（MB）"""
        if not torch.cuda.is_available():
            return 0.0
        total = torch.cuda.get_device_properties(0).total_memory / 1024 / 1024
        used = torch.cuda.memory_allocated(0) / 1024 / 1024
        return total - used

    def get_system_status(self) -> SystemStatus:
        """获取系统状态快照"""
        # CPU 和内存
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()

        # GPU 状态
        gpus = []
        if torch.cuda.is_available():
            for i in range(torch.cuda.device_count()):
                props = torch.cuda.get_device_properties(i)
                memory_used = torch.cuda.memory_allocated(i) / 1024 / 1024
                memory_total = props.total_memory / 1024 / 1024

                gpu_status = GPUStatus(
                    index=i,
                    name=props.name,
                    memory_used=memory_used,
                    memory_total=memory_total,
                    memory_percent=(memory_used / memory_total * 100) if memory_total > 0 else 0
                )

                # 尝试获取温度和利用率（需要 nvidia-smi）
                try:
                    import pynvml
                    pynvml.nvmlInit()
                    handle = pynvml.nvmlDeviceGetHandleByIndex(i)
                    gpu_status.temperature = pynvml.nvmlDeviceGetTemperature(
                        handle, pynvml.NVML_TEMPERATURE_GPU
                    )
                    utilization = pynvml.nvmlDeviceGetUtilizationRates(handle)
                    gpu_status.utilization = utilization.gpu
                except:
                    pass

                gpus.append(gpu_status)

        return SystemStatus(
            cpu_percent=cpu_percent,
            memory_used=memory.used / 1024 / 1024,
            memory_total=memory.total / 1024 / 1024,
            memory_percent=memory.percent,
            gpus=gpus
        )

    async def start_monitoring(self, interval: int = 5):
        """启动实时监测"""
        if self.monitoring:
            return

        self.monitoring = True
        self.monitor_task = asyncio.create_task(self._monitor_loop(interval))
        self.logger.info("硬件监测已启动")

    async def stop_monitoring(self):
        """停止监测"""
        self.monitoring = False
        if self.monitor_task:
            self.monitor_task.cancel()
        self.logger.info("硬件监测已停止")

    async def _monitor_loop(self, interval: int):
        """监测循环"""
        while self.monitoring:
            try:
                status = self.get_system_status()

                # 检查 OOM 风险
                for gpu in status.gpus:
                    if gpu.memory_percent > 90:
                        self.logger.warning(
                            f"GPU {gpu.index} 显存使用率过高: {gpu.memory_percent:.1f}%"
                        )

                # 检查 CPU 和内存
                if status.cpu_percent > 90:
                    self.logger.warning(f"CPU 使用率过高: {status.cpu_percent:.1f}%")

                if status.memory_percent > 90:
                    self.logger.warning(f"内存使用率过高: {status.memory_percent:.1f}%")

                await asyncio.sleep(interval)
            except Exception as e:
                self.logger.error(f"监测循环错误: {e}")
                await asyncio.sleep(interval)


# 全局监测器实例
hardware_monitor = HardwareMonitor()
```

### 10.2 监控 API

**文件**: `backend/app/api/routes/monitor_routes.py`

```python
from fastapi import APIRouter
from app.services.monitoring.hardware_monitor import hardware_monitor

router = APIRouter(prefix="/api/monitor", tags=["monitoring"])

@router.get("/system/status")
async def get_system_status():
    """获取系统状态"""
    status = hardware_monitor.get_system_status()
    return {
        "cpu_percent": status.cpu_percent,
        "memory": {
            "used": status.memory_used,
            "total": status.memory_total,
            "percent": status.memory_percent
        },
        "gpus": [
            {
                "index": gpu.index,
                "name": gpu.name,
                "memory_used": gpu.memory_used,
                "memory_total": gpu.memory_total,
                "memory_percent": gpu.memory_percent,
                "temperature": gpu.temperature,
                "utilization": gpu.utilization
            }
            for gpu in status.gpus
        ]
    }

@router.post("/system/start")
async def start_monitoring(interval: int = 5):
    """启动实时监测"""
    await hardware_monitor.start_monitoring(interval)
    return {"message": "监测已启动", "interval": interval}

@router.post("/system/stop")
async def stop_monitoring():
    """停止监测"""
    await hardware_monitor.stop_monitoring()
    return {"message": "监测已停止"}
```

---
## 11. 置信度保留设计

### 11.1 置信度数据模型

**文件**: `backend/app/models/confidence_models.py`

```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class WordTimestamp:
    """字级时间戳（带置信度）"""
    word: str
    start: float
    end: float
    confidence: float  # SenseVoice 原始置信度
    is_pseudo: bool = False  # 是否为伪对齐生成的时间戳
    source: str = "sensevoice"  # 来源: sensevoice/whisper/alignment

@dataclass
class SentenceSegment:
    """句子片段（带置信度）"""
    text: str
    start: float
    end: float
    words: List[WordTimestamp]

    # 置信度指标
    sentence_confidence: float  # 句级平均置信度
    min_word_confidence: float  # 最低字级置信度
    max_word_confidence: float  # 最高字级置信度

    # 质量标记
    needs_review: bool = False  # 是否需要人工审核
    warning_type: Optional[str] = None  # 警告类型: low_confidence/short_segment/single_char

    # 来源标记
    whisper_patched: bool = False  # 是否经过 Whisper 补刀
    llm_proofread: bool = False  # 是否经过 LLM 校对

    def calculate_confidence_stats(self):
        """计算置信度统计"""
        if not self.words:
            return

        confidences = [w.confidence for w in self.words]
        self.sentence_confidence = sum(confidences) / len(confidences)
        self.min_word_confidence = min(confidences)
        self.max_word_confidence = max(confidences)

        # 判断是否需要审核
        if self.sentence_confidence < 0.6:
            self.needs_review = True
            self.warning_type = "low_confidence"

@dataclass
class AlignedSubtitle:
    """对齐后的字幕（完整置信度信息）"""
    text: str
    start: float
    end: float
    words: List[WordTimestamp]

    # 对齐质量指标
    alignment_score: float = 1.0  # 对齐质量分数 (0-1)
    pseudo_ratio: float = 0.0  # 伪对齐比例

    # 原始数据保留
    sensevoice_text: Optional[str] = None  # SenseVoice 原始文本
    whisper_text: Optional[str] = None  # Whisper 原始文本

    def calculate_metrics(self):
        """计算对齐指标"""
        if not self.words:
            return

        # 计算伪对齐比例
        pseudo_count = sum(1 for w in self.words if w.is_pseudo)
        self.pseudo_ratio = pseudo_count / len(self.words)

        # 计算对齐质量分数（伪对齐越多，分数越低）
        self.alignment_score = 1.0 - (self.pseudo_ratio * 0.3)
```

### 11.2 置信度在流水线中的传递

```python
# backend/app/pipelines/dual_alignment_pipeline.py

class DualAlignmentPipeline:
    async def run(self, job_id: str, chunks: List[AudioChunk], config: JobConfig):
        for i, chunk in enumerate(chunks):
            # 1. SenseVoice 推理（保留原始置信度）
            sv_result = await self.sv_executor.transcribe(
                audio=chunk.audio,
                device="cpu",
                language=config.language
            )
            # sv_result.word_timestamps 包含每个字的置信度

            # 2. Whisper 推理
            whisper_result = await self.whisper_executor.transcribe(
                audio=chunk.audio,
                language=config.language
            )

            # 3. 对齐（保留置信度）
            final_subtitle = await self.aligner.align(
                whisper_text=whisper_result.text,
                sv_tokens=sv_result.word_timestamps,  # 带置信度
                vad_range=(chunk.start, chunk.end),
                chunk_offset=chunk.start
            )

            # 4. 保留原始数据
            final_subtitle.sensevoice_text = sv_result.text
            final_subtitle.whisper_text = whisper_result.text
            final_subtitle.calculate_metrics()

            # 5. 推送（包含置信度信息）
            await self.sse_publisher.publish_overwrite(
                job_id=job_id,
                chunk_id=chunk_id,
                subtitle=final_subtitle
            )
```

### 11.3 前端置信度可视化

**文件**: `frontend/src/components/editor/SubtitleItem.vue`

```vue
<template>
  <div :class="['subtitle-item', confidenceClass]">
    <div class="subtitle-header">
      <span class="time">{{ formatTime(subtitle.start) }} --> {{ formatTime(subtitle.end) }}</span>
      <span class="confidence-badge" :class="confidenceBadgeClass">
        {{ (subtitle.confidence * 100).toFixed(0) }}%
      </span>
    </div>

    <div class="subtitle-text">
      <span
        v-for="(word, idx) in subtitle.words"
        :key="idx"
        :class="getWordClass(word)"
        :title="`置信度: ${(word.confidence * 100).toFixed(1)}%`"
      >
        {{ word.word }}
      </span>
    </div>

    <div v-if="subtitle.needs_review" class="warning-banner">
      <span class="warning-icon">⚠</span>
      <span>{{ getWarningMessage(subtitle.warning_type) }}</span>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  subtitle: Object
})

const confidenceClass = computed(() => {
  const conf = props.subtitle.confidence
  if (conf >= 0.85) return 'confidence-high'
  if (conf >= 0.6) return 'confidence-medium'
  return 'confidence-low'
})

const confidenceBadgeClass = computed(() => {
  const conf = props.subtitle.confidence
  if (conf >= 0.85) return 'badge-success'
  if (conf >= 0.6) return 'badge-warning'
  return 'badge-danger'
})

const getWordClass = (word) => {
  if (word.is_pseudo) return 'word-pseudo'
  if (word.confidence < 0.5) return 'word-low-confidence'
  return 'word-normal'
}

const getWarningMessage = (type) => {
  const messages = {
    'low_confidence': '低置信度，建议人工审核',
    'short_segment': '片段过短，可能不准确',
    'single_char': '单字符结果，已自动补刀'
  }
  return messages[type] || '需要审核'
}
</script>

<style scoped>
.confidence-high {
  border-left: 3px solid #52c41a;
}

.confidence-medium {
  border-left: 3px solid #faad14;
}

.confidence-low {
  border-left: 3px solid #ff4d4f;
  background-color: #fff1f0;
}

.word-low-confidence {
  background-color: #fff3cd;
  padding: 2px 4px;
  border-radius: 2px;
}

.word-pseudo {
  font-style: italic;
  opacity: 0.8;
}

.warning-banner {
  background-color: #fff3cd;
  border: 1px solid #ffc107;
  padding: 8px;
  margin-top: 8px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}
</style>
```
